% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cost.R
\name{make_stress_fn}
\alias{make_stress_fn}
\title{Factory function to convert a cost function to a stress function.}
\usage{
make_stress_fn(cost_fn, mat_name = "qm")
}
\arguments{
\item{cost_fn}{Cost function. Should have the signature
\code{cost_fn(inp, out)} and return a scalar numeric cost value. In addition
it should have an appropriate \code{sneer_cost_type} attribute set. For cost
functions that act on probabilities, this should be \code{"prob"}. For cost
function that act on distances, this should be \code{"dist"}.}

\item{mat_name}{The name of the matrix in the \code{out} list that will be
used by the \code{cost_fn} to calculate the cost.}
}
\value{
Stress function with the signature \code{stress_fn(inp, out)} and
which return a scalar numeric stress value.
}
\description{
The cost function can be any function where the more positive the value,
the worse the solution is considered to be. The corresponding stress
function is that which scales the cost so that a "null" model would give a
stress of 1.0.
}
\details{
This definition of stress is in analogy with the Kruskal stress used in
classical MDS. A "null" model is considered to be one where e.g. for
distance-based methods the distances are equal (i.e. zero) or, for similarity
methods, where all probabilities are equal. The point is to scale the
cost so that embeddings that do worse than this are obvious, no matter
what the divergence or weighting functions are used.

It might also be possible to compare embeddings between different methods,
but it's safer to simply use it with one method, and know that while an
embedding with a stress of e.g. 0.85 is poor, one with a stress of 1.2 is
worse than random.
}

