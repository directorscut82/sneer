% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cost.R
\name{make_normalized_cost_fn}
\alias{make_normalized_cost_fn}
\title{Factory function to normalize a cost function.}
\usage{
make_normalized_cost_fn(cost_fn)
}
\arguments{
\item{cost_fn}{Cost function. Should have the signature
\code{cost_fn(inp, out)} and return a scalar numeric cost value. In addition
it should have an appropriate \code{sneer_cost_type} attribute set. For cost
functions that act on probabilities, this should be \code{"prob"}. For cost
function that act on distances, this should be \code{"dist"}.}
}
\value{
Normalized cost function with the signature
\code{norm_fn(inp, out)} and which return a scalar numeric cost value.
}
\description{
The cost function can be any function where the more positive the value,
the worse the solution is considered to be. The corresponding normalized
version is that which scales the cost so that a "null" model would give a
normalized cost of 1.0.
}
\details{
The definition of a "null" model is one which is as good as can be if one
didn't use any information from the data at all. For methods that attempt
to preserve distances, this would be equivalent to making all the embedded
distances the same, which can only be achieved by making them all zero. For
similarity-preserving methods, the equivalent would be to make all the
probabilities equal.

It might also be possible to compare embeddings between different methods,
but it's safer to simply use it with one method, and know that while an
embedding with a normalized cost of e.g. 0.85 is poor, one with a normalized
cost of 1.2 is basically worse than guessing.
}

