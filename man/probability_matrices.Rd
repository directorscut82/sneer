% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dist_to_sim_stiff.R
\name{probability_matrices}
\alias{probability_matrices}
\title{Probability Matrices}
\description{
For probability-based embedding, sneer works with three types of probability
matrix.
}
\section{Row Probabilities}{

Matrix contains N different probability distributions, where N is the number
of rows (or columns). Each row sums to one. This structure is called a row
stochastic matrix when used in Markov Chains.

In the context of embedding, this structure represents a point-based
probability: a given entry \code{P[i, j]} should be considered the
conditional probability pj|i, the probability that point j is a neighbor of
i, given that i has been picked as the reference point.

Given the potentially different inhomogeneous distribution of points
in a data set, there is therefore no reason that \code{P[i, j]} should be
equal to \code{P[j, i]}: the probability that point i is a neigbour of point
j is not necessarily the same that j is a neighbor of i.

Row probability is the model used in the original (asymmetric) Stochastic
Neighbor Embedding paper.

In sneer, row probability matrices should be given a \code{type} attribute
with value \code{row}.
}

\section{Joint Probabilities}{

Matrix contains 1 probability distribution. The grand sum of the matrix is
one.

In the context of embedding, this structure represents a pair-based
probability: a given entry \code{P[i, j]} should be considered the
joint probability pij, the probability that point i and point j are selected
as a pair. From this point of view, whether the pair is represented as
\code{P[i, j]} or \code{P[j, i]} should be irrelevant. Therefore a joint
probability is symmetric.

Joint probability is the model used in Symmetric Stochastic Neighbor
Embedding and t-Distributed Stochastic Neighbor Embedding. Although both
methods use the same techniques and procedures as ASNE, they introduce
further steps to process the input probability, which they convert from a
row probability form to a joint probability by taking the average of
\code{P[i, j]} and \code{P[j, i]} and then renormalizing. The output
probabilities don't require the averaging step, because the weight function
used in SSNE and t-SNE is symmetric. Only the normalization step is required.

In sneer, joint probability matrices should be given a \code{type} attribute
with value \code{joint}.
}

\section{Conditional Probabilities}{

An intermediate step between a row probability matrix and a joint probability
matrix. The matrix contains 1 probability distribution. The grand sum of the
matrix is one.

In the context of embedding, this structure represents a pair-based
probability: a given entry \code{P[i, j]} should be considered the
conditional probability pj|i, the probability that point i and point j are
selected as a pair, given that point i was selected first.

Unlike the joint probability, there is no restriction that \code{P[i, j]} be
equal to \code{P[j, i]}. The question is whether you can justify that making
sense in your model of embedding.

No embedding I'm aware of uses conditional probabilities directly. However,
the output probabilities in SSNE and t-SNE could be thought of as a special
case of a conditional matrix: yes, the output \code{P[i, j]} is equal to
\code{P[j, i]}, so they're technically joint probabilities, but no special
effort was made to make them joint, unlike their counterpart matrices in
the input case: those need to be explicitly normalized and then symmetrized.
The jointness of the output probabilities in SSNE and t-SNE is entirely a
by-product of the symmetric nature of the weighting function used to generate
the similarities. In SSNE, if the beta parameter was allowed to vary between
points in the output probability, for example, then the resulting matrix
would have to be symmetrized to be a joint probability (note also that the
stiffness matrix function would have to be rewritten!).

In sneer, joint probability matrices should be given a \code{type} attribute
with value \code{joint}.
}
\examples{
\dontrun{
# Setting the row probability type
prow <- some_func()
attr(prow, "type") <- "row"

#' # Setting the joint probability type
pjoint <- some_other_func()
attr(pjoint, "type") <- "joint"

# Setting the conditional probability type
pcond <- yet_another_func()
attr(pcond, "type") <- "cond"
}
}
\keyword{internal}

