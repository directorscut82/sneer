% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initialize_inp.R
\name{on_inp_updated}
\alias{on_inp_updated}
\title{Register a Function to Run When Input Data Changes}
\usage{
on_inp_updated(method, fn)
}
\arguments{
\item{method}{Embedding method to register the function with.}

\item{fn}{Function to run when the input data changes.}
}
\value{
List containing the updated method.
}
\description{
Call this function to register a callback to run when the input data changes.
}
\details{
For example, in \code{\link{nerv}}, the output kernel precisions are the
same as those of the input kernel. Hence, it registers a function to transfer
those value from the input data to the output kernel. This may be called
multiple times if the probability is recalculated (e.g. due to multiple
perplexity calculations).

Similarly, the importance-weighted modifications of an embedding uses the
input probability to generate a further weighting of the output kernels.

The above two examples, although they both modify the kernel, can co-exist
peacefully, because they affect two different parameters. However, the
approach suggested in the multiscaling approach involves choosing a single
precision value for the output kernel which is scaled compared to those
used with the input kernel. This is in direct conflict with the NeRV
approach.

Ideally, we would be able to detect which update functions interfere with
each other, and then ensure that only the most recently registered function
was retained in the list of callbacks. But that sounds horrifically complex.
Instead, when a function is registered here, it runs after previously
registered callbacks. So if NeRV is modified to use multiscaling, the
multiscale approach will "win" because it will run after the NeRV update
function, and then overwrite the precision argument set by the NeRV update
with its own value. This is only practical because pointlessly running
the original NeRV update isn't very time consuming relative to the rest of
the embedding.

The function to register should have the signature
\code{fn(inp, out, method)} and return a list containing any of the modified
arguments.
}

