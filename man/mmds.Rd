% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mds.R
\name{mmds}
\alias{mmds}
\title{Metric Multi-dimensional Scaling (MDS) Using STRESS Cost Function}
\usage{
mmds(eps = .Machine$double.eps)
}
\arguments{
\item{eps}{Small floating point value used to prevent numerical problems,
e.g. in gradients and cost functions.}
}
\value{
a list containing:
 \item{\code{cost_fn}}{Cost function for the embedding: for this
 implementation of MDS, the unweighted residual sum of squares between
 the distances.}
 \item{\code{stiffness_fn}}{Stiffness function for \code{cost_fn}.}
 \item{\code{update_out_fn}}{Function to calculate and store any needed
 data after a coordinate update.}
 \item{\code{eps}}{Small floating point value used to prevent numerical
 problems, e.g. in gradients and cost functions.}
}
\description{
A distance-based embedding method.
}
\details{
This function minimizes an embedding using \code{\link{metric_stress_cost}}
as the cost function:

\deqn{STRESS = \sum_{i<j} (r_{ij} - d_{ij})^2}{STRESS = sum(rij-dij)^2}

\eqn{r_{ij}}{rij} is the input distance between point \eqn{i} and point
\eqn{j} and \eqn{d_{ij}}{dij} is the corresponding output distance.

MDS is an umbrella term for many algorithms, with an emphasis on
non-metric problems, i.e. those where the input distance is not a metric.
The non-metric stress loss function has a slightly different definition, so
when comparing the result of this embedding method with that of other MDS
algorithms, you need to be quite sure exactly how the stress is being
calculated, which may not be apparent without examining the source code.
}
\section{Output Data}{

If used in an embedding, the output data list will contain:
\describe{
 \item{\code{ym}}{Embedded coordinates.}
 \item{\code{dm}}{Distance matrix generated from \code{ym}.}
}
}
\seealso{
There are a plethora of MDS algorithms implemented in R. For non-metric MDS,
the most commonly reported loss function is the Kruskal
Stress (also known as Stress-1), which when applied to a metric problem is:

\deqn{K = \sqrt{\frac{\sum_{i<j} (r_{ij} - d_{ij})^2}{\sum_{i<j} d_{ij}^2}}}{K = sqrt(sum(rij-dij)^2/sum(dij^2))}

i.e. the square root of a normalized metric stress, where the normalization
is by the sum of the squares of the embedded distances. Some functions in other
packages which use this include:
\describe{
\item{\code{\link[MASS]{isoMDS}}}{Also applies a monotonic
transformation to the input distances to lower the stress, so the reported
stress and the output configuration can't be directly compared to the output
of a sneer MDS embedding.}
\item{\code{\link[smacof]{mds}}}{Applies ratio metric MDS, which attempts
to preserve the ratio of the distances in the input and output space. The
result of this function is a list, containin a member \code{stress}, which
is the Kruskal Stress, so can be compared to the
\code{\link{kruskal_stress_cost}} of a sneer embedding. However, the embedded
configuration in the result, \code{conf} configuration, is will not on the
same scale as the input coordinates.}
\item{\code{\link[stats]{cmdscale}}}{Doesn't use Kruskal Stress, but
implements a form of classical metric MDS called Principal Coordinate
Analysis. However, note that if the input distances are Euclidean (which
they are in sneer), the result is identical to PCA, so the output will
always have a higher stress than the sneer MDS embedding.}
}

Other sneer distance embedding methods: \code{\link{distance_embedding_methods}},
  \code{\link{sammon_map}}, \code{\link{smmds}}

Other sneer embedding methods: \code{\link{asne}},
  \code{\link{embedding_methods}}, \code{\link{hsnerv}},
  \code{\link{hssne}}, \code{\link{nerv}},
  \code{\link{sammon_map}}, \code{\link{smmds}},
  \code{\link{snerv}}, \code{\link{ssne}},
  \code{\link{tasne}}, \code{\link{tnerv}},
  \code{\link{tsne}}
}

